We want to add the expressions in the syntax tree
An expression is any set of words which produces an output

program -> expression* EOF;
expression -> exprStmt | printStmt;
exprStmt -> expression ";" ;
printStmt -> "print" expression ";" ;

When we decide to add variable declarations and all the rest;
program -> declaration* EOF;
declaration -> varDecl | statement;
statement -> exprStmt | printStmt;

varDecl -> "var" IDENTIFIER ("=" expression )? ";" ;"
 -- In order to handle the using variable names (IDENTIFIERS)
primary -> "true" | "false" | "nil" | NUMBER | STRING | "(" expression ")" | IDENTIFIER;

-- Added the exponent operator '^'

l-values evaluate to something we can store into(variable)
r-values evaluate to something that produces a value e.g Expressions

expression -> assignment;
assignment -> IDENTIFIER "=" assignment | equality;


The scope of a code is also called the static scope

Shadowing is when the same variable is declared in an inner scope, and so it hides the outer scope
When we enter an inner scope, We define a fresh environment for each scope. Which will reference all the variables of its outerscope and when we exit
the inner scope, we just clear that environment

Updated grammar with scopes:
statement -> exprStmt | printStmt | block;
block -> "{" declaration* "}"

If statements:
statements -> exprStmt | ifStmt |  ...;
ifStmt -> "if" "(" expression ")" statement
          ( "else" statement )? ;



expression -> assignment;
assignment -> IDENTIFIER "=" assignment | logic_or;
logic_or -> logic_and ("or" logic_and )*;
logic_and -> equality ("and" equality )*;


The function call in func_name(arg1, ..., argn) is actually the '('
We desugar for loops to while loops

---------------------------ADDING FUNCTIONS--------------------------------

unary -> ("!" | "-") unary | call;
call -> primary ( "(" arguments? ")" )*;
arguments -> expression ("," expression)*;

The arity of a function is the number of parameters it needs

A lisp-1 language is one which stores variables and functions in the same namespace and Lisp-2 is otherwise

-- Consider the function below. The stack trace when we reach the return n; is
fun count(n) {
while (n < 100) {
if (n == 3) return n; // <--
print n;n = n + 1;
}
}
count(1);


Interpreter.visitReturnStmt()
    -> Interpreter.visitIfStmt()
    -> Interpreter.executeBlock()
    -> Interpreter.visitBlockStmt()
    -> Interpreter.visitWhileStmt()
    -> Interpreter.executeBlock()
    -> LoxFunction.call()
    -> Interpreter.visitCallExpr()


Resolving a variable or function means tracking down which declaration  it refers to.
We have semantic and syntatic analysis. The semantic analyses starts to check our code and say what each bunch of code means. Like, it can find all calls to variables in the entire code and resolve them at once.

--SCOPES AND ENVIRONMENT--
We reach a problem because our scopes are mutable. When a function inherits a scope at a point in time and the original user of the scope
updates it, it is not normal for the update to happen to the one who inherited it.
The function should capture a frozen snapshot of the environment as it existed at the
moment the function was declared.


the Resolver and Interpreter match each other so that the Interpreter can have full confidence



